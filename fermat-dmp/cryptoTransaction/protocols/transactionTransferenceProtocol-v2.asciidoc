= Transaction Transference Protocol - Version 2 (DRAFT)

Date: Jun 6th 2015 +
Author: Ezequiel Postan <ezequiel_postan@hotmail.com>

== Consideraciones

* No se puede depender sólo de los eventos informativos IncomingCryptoReceivedEvent e IncomingCryptoReversedEvent porque pueden detectarse transacciones crypto confirmadas sin que haya visto la primer confirmación (porque estaba apagado el equipo por ejemplo). El protocolo de traspaso de transacciones sólo depende de un evento que exige el traspaso de transacciones pendientes, usaresmo el evento IncomingCryptoTransactionsWaitingTransferenceEvent.

== Probelmas de la versión 1

* No separaba los conceptos de transacción de la red crypto y transacción de la plataforma. Cosa que notaremos más adelante.
* No plantea cómo organizar las cosas para reutilizar el protocolo para comunicar MetaTransactionInformation provenientes de los network services.
* Problema "menor", podría ser más eficiente


== Definiciones preliminares

Agente:: Thread que realiza un trabajo en paralelo.
Transacción crypto:: Mecanismo por el cual una red de crypto currencies registra el traspaso de valor de un usuario a otro.
Transacción:: Tarea de modificar los estados de las wallets y crypto volt de manera transaccional
Action:: Enum que lista qué debe hacerse con la transacción crypto que se traspasa. Los valores son:
** APPLY: Para que se aplique la transacción
** REVERT: Para revertir la transacción

CryptoState:: Enum que lista los cuatro posbles estados de una transacción crypto. Estos son:
** IDENTIFIED: Cuando se ve la transacción crypto en la red pero sin ninguna confirmación
** RECEIVED: Cuando la transacción crypto obtiene la primer confirmación.
** CONFIRMED: Cuando la tramsacción crypto obtiene suficientes confrmaciones para considerar la transacción irreversble.
** REVERSED: Cuando se reverte la transacción.

Specialist:: Enum que lista qué tipo de plug-in debe tomar poseción de la transacción a traspazar. Este enum es necesario dado que este plug-in debe dar distintas transacciones a distintos plug-ins, por ende cuando un plug-in venga a tomar posesión de una transacción debe indicar qué tipo de transacciones maneja.
CryptoTransaction:: Contenedor de datos con la información de una transacción. Esta información es: 
** Hash de la transacción
** Dirección de Origen
** Dirección de Destino
** Crypto Currency
** CryptoState
** Monto

Transaction:: Contenedor de datos con la información de una transacción. Estos datos son:
** Un identificador distintivo (TransactionId)
** Un elemento de tipo CryptoTransaction
** Un valor de Action (Apply, Revert)
** Un valor de Specialist (en principio los receptores de transacciones crypto pueden ignorar este campo, en cualquier caso para mencionar al incomingcrypto se usa el valor CRYPTO_ROUTER)

TransactionStatus:: Estado interno que guarda un plug-in sobre cadaa transacción que describe su relación con la misma. El estado puede ser:
** ACKNOWLEDGE: Cuando recibe una transacción pero aún no confirmó su recepción.
** RESPONSIBLE: Cuando posee la transacción y aún no la aplicó ni la traspasó
** DELIVERED: Cuando traspasó la transacción a otro plug-in para que este se haga responsable.
** APPLIED: Cuando aplicó la transacción

ProtocolStatus:: Estado interno que guarda un plug-in sobre cada transacción que describe su situación de traspaso de la misma. Este estado puede ser:
** NO_ACTION_REQUIRED: Cuando se tiene una transacción pero no se requiere ejecutar ningún traspaso o aplicación aún.
** TO_BE_NOTIFIED: Cuando se debe notificar un evento para iniciar el traspaso de una transacción.
** SENDING_NOTIFIED: Cuando se emitió el evento que notifica el pedido de traspaso de la transacción.
** RECEPTION_NOTIFIED: Cuando se recibe la confirmación de receptión del traspaso de una transacción.

TransactionSender:: Interfaz que implementan los plug-ins que traspasan transacciones a otros módulos, brinda los siguientes métodos:

```
  void confirmReception(TransactionId transactionId)
  List<Transaction> getPendingTransactions(Specialist specialist)
```

  El método confirmedReception marca la transacción marcada como argumento como (DELIVERED,RECEPTION_NOTIFIED).
  El método getPendingTransactions retorna la lista de todas las transacciones con ProtocolStatus SENDING_NOTIFIED que tienen como Specialist al pasado como argumento.

== Convensiones

* Escribiremos que una transacción tiene un estado (A,TS,PS) para describir que su Action es A, su TransactionStatus es TS y el ProtocolStatus es PS.
* Dada una transacción crypto, una transacción asociada es una transacción que tiene como CryptoTransaction un contenedor con los datos de la transacción crypto. Notar que una misma transacción crypto puede tener más de una transacción asociada. Esto se da por ejemplo cuando, al detectar que una transacción es confrmada por primera vez se genera un objeto Transaction con valor de Action `Apply`, y si esta transacción crypto se reversa generará un nuevo objeto transaction pero este tendrá como Action el valor `Revert`

== Protocolo

Para simplificar la explicación supondemos que el receptor de las transacciones crypto y por ende el emisor original de las transacciones es el plug-in de la red bitcoin. A su vez, usaremos el término 'red bitcoin' para referirnos a este plug-in.

Analicemos los pasos del protocolo de traspaso de transacciones en estos componentes.

. Cuando la red bitcoin despierta, revisa las transacciones *nuevas* que han llegado por la red. Al analizar el crypto estado de cada transacción crypto se tendrá varias opciones:
.. Si el crypto estado es RECEIVED o CONFIRMED, almacena una transacción asociada con estado (APPLY,RESPONSIBLE,TO_BE_NOTIFIED)
.. Si el crypto estado es REVERCED, almacena una transacción asociada con estado (REVERT,RESPONSIBLE,TO_BE_NOTIFIED). <<Transaction-Transference-Protocol-v2-Note1,VER NOTA>>
.. Si el crypto estado es IDENTIFIED, no almacena una transacción asociada ya que no debe aplicarse aún.
. Un agente de la red bitcoin detecta que hay transacciones crypto con ProtocolStatus TO_BE_NOTIFIED o SENDING_NOTIFIED, entonces envía el evento IncomingCryptoTransactionsWaitingTransferenceEvent. Luego de lanzar el evento marca las transacciones que tenía en TO_BE_NOTIFIED como SENDING_NOTIFIED. <<Transaction-Transference-Protocol-v2-Note2,VER NOTA>>
. El IncomngCrypto regstra el evento.
. Un agente del IncomingCrypto ve que hay transacciones pendientes y llama al método `getPendingTransactions(CRYPTO_ROUTER)`, luego recorre la lista que devuelve y por cada transacción ejecuta los siguientes pasos *en ese orden*:
.. Almacena la transacción recibida con estado (ACKNOWLEDGE,TO_BE_NOTIFIED)
.. Llama al método `confirmReception` con el TransactionId de la transacción como parámetro
.. Marca la transacción como (RESPONSIBLE,NO_ACTION_REQUIRED)
. Un segundo agente de IncomingCrypto analizará las transacciones con estado (RESPONSIBLE,NO_ACTION_REQUIRED). Por cada una de ellas haría los siguientes pasos *en el orden enunciado* 
.. Deduciría a partir de la información de las mismas su Specialist y lo marcaría. 
.. Pasaría la transacción al estado (RESPONSIBLE,TO_BE_NOTIFIED)
.. Cuando termina de recorrer la lista recorre ahora todas las que están con TransactonStatus RESPONSIBLE y ProtocolStatus TO_BE_NOTIFIED o SENDING_NOTIFIED. Registra todos los especialistas que vio en este recoorido y realiza los siguente pasos *en el orden enunciado*:
... Por cada Specialist registrado en el recorrido anterior lanza el evento correspondiente (IncomingCryptTransactionsWaitingTransferenceSpecalistEvent)
... Pasa por cada transacción con ProtocolStatus TO_BE_NOTIFIED a SENDING_NOTIFED. <<Transaction-Transference-Protocol-v2-Note3,VER NOTA>>

Eventualmente el IncomingCrypto especializado llamará al receptonConfirmed. +

[[Transaction-Transference-Protocol-v2-Note1]]
NOTE: Quiero analizar la posibilidad de cancelar aquí mismo el envío del APPLY de la transacción si aún no se envió, pero es algo tarde cuando escribo esto, voy a verlo al levantarme con mi mente más despierta. A diferencia de la <<Transaction-Transference-Protocol-v2-Note3,últma nota>> aquí no es tan simple, porque el que notifica es otro thread.

[[Transaction-Transference-Protocol-v2-Note2]]
NOTE: DESPUÉS VI ESTO MÁS DESPEJADO Y ME DI CUENTA QUE ESTE PROBLEMA NO SE DA, PORQUE EL MÉRODO `getPrndeingTransactions` NO ENTREGARÍA TRANSACCIONES EN ESTADO TO_BE_NOTFIED, podría ignorarse esta nota, la dejé para recordarlo yo. +
Esto visto en detalle muestra problemas de concurrencia nuevamente, ejemplo: lanzo el evento y el incoming crypto toma las transaccones, las confirma y cuando luego de confirmarlas es que recíen este agente marca la transaccón al estado SENDING_NOTIFED, aquí dependo de cómo esté implementado el módulo de base de datos para saber si esto puede andar mal (no sólo en si la base de datos usa un lock, sino tambien en cuanto a cómo actualiza un campo). Analizado sin mucho detalle creo que podría causar problemas al incorporar los reversed. Creo que con colocar un lock se podría solucionar. + 

[[Transaction-Transference-Protocol-v2-Note3]]
NOTE: Acá hay que analizar de nuevo la posibilidad de cancelar el envió de transacciones con acción APPLY si ya tengo registrado el REVERSED. Creo que en este caso puedo cancelar el traspaso si la transaccón tiene ProtocolStatus TO_BE_NOTIFIED.

== Conclusiones hasta aquí

* Las consideraciones de cambio que tengo presentes son:
** Incorporación de nuevos especalistas
** Los criterios de decisión se podrían encapsular en clases y usar el patrón de diseño strategy. Pero esto no llegué a verlo.
** Consultas de informacón: Para que se consulte información, se podría tener uno o más métodos que simplemente no cambien ningún estado interno y retornen la información pedida.
* Si parametrizamos el protocolo haciendo que la interfaz TransactionSender tenga un parámetro de tipo genérico podríamos reutilizar el protocolo con otro tipo de transacciones, simplemente cambiaríamos la clase CryptoTransaction por otro contenedor de datos que usarían el emisor y receptor.
* Parece ser más eficiente porque elimina un par de agentes.
* Creo que los Network Services que transporten información de valor que deba sincronizarse usarían este protocolo con eventos especializados que indiquen nuevas meta-transacciones.
* Aún hay que revisar esto y completar los pasos con el incoming-crypto-extra-user y ver si incorporar el incoming-crpyo-intra-user no rompe nada
* Falta analizar el impacto del cambio de usar una transacción crypto por cada meta transacción a pasar a usar una UTXO por cada meta transacción. 
