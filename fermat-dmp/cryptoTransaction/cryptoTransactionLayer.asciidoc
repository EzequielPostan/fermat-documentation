[[Fermat-DMP-CryptoTransactionLayer]]
= Crypto Transaction Layer

[[Fermat-DMP-CryptoTransactionLayer-LayerDescription]]
== Layer Description

Transactions are one of the core functionalities developed over Fermat. +
Fermat uses crypto currencies to transfer the real value from a user to another, but we have to remember that you can make transactions of other assets apart from crypto currencies. +
For example, we can transfer 100 dollars from one wallet to another. The mechanism to do this involve the value transaction which is managed by transferring an amount of crypto currency like bitcoin equivalent to 100 dollars between the users and an information transaction which provide the information about the meaning of those bitcoins. In this case the information would be that the bitcoins sent by the crypto network are represented as 100 dollars. +

Therefore, when we make a transaction in Fermat we can identify two components: *meta data* and *value*. +
The value at this moment is stored at a crypto vault, specifically under a crypto addresses managed managed by the vault plugin. On the other hand the information tell us, among other things, which and how much fiat currency or other asset is beign transmitted. +

The meta data and the value travel through different channels, so they will be be acknowledged by a device at different moments in time. This means that we can receive a notification that 100 dollars have been sent to us before we get any new bitcoins that represent the value or vice versa, we can get new bitcoins before receiving the notification of what those bitcoins represent and why they have been sent. +

The responsibility of this layer is to keep these concepts synchronized and within each device the transactional and balance information in a consistent state. The plug-ins that live here detect the arrival of value and information and will update the balances of the system vaults and wallets in an atomic transactional way, i.e. they will update things only when both meta data *and* value are acknowledged. +
No loss of value nor meta data can be permitted. The mechanisms implemented by this layer will need to contemplate many different kinds of problems (device shut down, network failure, etc.).

NOTE: The plug-ins in this layer will need to communicate with the wallets and crypto vaults using events or at least a more complex mechanism that simple method call. The plug-ins need to know that the information inside the wallets and volt was actually updated and persisted before ending the synchronization protocol.

In the next section we will explore a general idea behind the protocols and failures considered in the design of this layer.

== Transaction Data Structure

To attack the problems we deal with in this layer we will need to design a few data structures to contain and share important information. +
To simplify the analysis let's give a name to the data strcutures that contains the value and information associated to the fermat transaction. We will call them TransactionInformation and MetaTransactionInformation respectively. +

As we will get the value and meta-value separetely and in no predictable order we will introduce in the MetaTransactionInformation a reference to the associated TransactionInformation. In this way we will be able to know when we have all the information needed to reflect the transaction in the wallets among other components. +

The TransactionInformation will store.

* The crypto currency we are dealing with as value.
* The amount of crypto currency. 
* A transaction identifier that distinguish the crypto transaction.
* The source crypto address of the transaction.
* The destination crypto address of the transaction.
* The timestamp that stablish the creation time of the transaction.

NOTE: In a single crypto transaction could be bundled many meta transactions. (Think for the future)

The MetaTransactionInformation will store:

. The asset represented by the transaction (fiat currency, bonds, etc)
. A representation of relevant information associated to the asset, e.g. in fiat currency would be the amount of currency involved.
. The transaction identifier of the associated TransactionInformation.
. The timestamp that stablish the creation time of the transaction. 

NOTE: We could consider as a simple secutiry mechanism to ask for this timestamp to be the same timestamp present in the associated TransactionInformation.

This cointainers descriptions are a draft presentation. We will add some fields to them to attack the syncronization problems. +

An important aspect to consider is that lower layers (like network services and crypto networks) will interact with this containers as they are the layers that will give us this information. +

[[Fermat-DMP-CryptoTransactionLayer-TransactionTransferProtocol]]
== Transaction Transfer Protocol (DRnAFT)

Este protocolo involucra dos tipos de módulos T y R. Los tipo T transfieren la responsabilidad de transacciones que poseen y los tipo R reciben la responsabilidad de las transacciones. El tener la responsabilidad significa que deben realizar alguna tarea con la información de la transacción transmitida. +

IMPORTANT: Este protocolo asume que los módulos tipo R saben quienes son sus T asociados (quienes les transmiten transacciones). Los módulos tipo T no conocen la ideantidad de los R.

Sean T un módulo de tipo T y R un módulo de tipo R. 
Debemos considerar algunas cosas:

. T puede realizar otras acciones previas a inicar el traspaso de la transación.
. R puede realizar alguna tarea tras recibir la transacción.

Para tener esto en cuanta en los pasos del protocolo, a cada transacción se le agregará un estado de la transacción y un estado de notificación, que notaremos como un par (ESTADO_DE_TRANSACCIÓN, ESTADO_DE_NOTIFICACIÓN). +

* El estado de la transacción podrá ser: ACKNOWLEDGED, RESPONSIBLE, DELIVERED o APPLIED.
* El estado de la notificación será NO_ACTION_REQUIRED, TO_BE_NOTIFIED o NOTIFIED. 

El significado y uso de cada estado se explicará a continuación junto con el protocolo.

NOTE: Cuando digamos que T recibe/registra una transacción nueva, nos referimos a que tiene una nueva transacción que procesar.

.Pasos del protocolo
. T registra una transacción nueva que debe procesar, entonces la guarda en su base de datos interna con el par de estados (RESPONSIBLE, NO_ACTION_REQUIRED). 
. Cuando T (siguiendo su lógica interna) concluye que debe enviar transacciones que están en el estado (RESPONSIBLE,NO_ACTION_REQUIRED) a otro módulo (que será de tipo R), pasa a estas transacciones al estado   (RESPONSIBLE, TO_BE_NOTIFIED).
. Periódicamente T revisa si tiene transacciones en la combinación (RESPONSIBLE,TO_BE_NOTIFIED) o (RESPONSIBLE, NOTIFIED). 
** Si tiene transacciones en alguno de esos pares de estados, envía el evento TransactionsWaitingTransferenceEvent, para que un módulo responsable se haga cargo y *luego de envíar el evento* pasa las transacciones del estado (RESPONSIBLE,TO_BE_NOTIFIED) al estado (RESPONSIBLE, NOTIFIED), las que ya estaban en NOTIFIED no cambian su estado. 
** Si no tiene transacciones en ese estado sigue con el análisis del resto de las transacciones.
. Por otro lado, cuando R escucha el evento que lanzó T, mira que el origen del evento es T y llama a un método de la interfaz de T que retorna una lista con todas las transacciones que tiene guardadas en estado (RESPONSIBLE, NOTIFIED). **T no cambia el estado de las transacciones que tiene almacenadas cuando R hace esta consulta.**
. R toma la lista y almacena en una base de datos interna cada transacción de a una a la vez con el estado (ACKNOWLEDGED, TO_BE_NOTIFIED). 
. Luego, para cada transacción en estado (ACKNOWLEDGED, TO_BE_NOTIFIED) en su base de datos, R llama a otro método de T al cual le pasa el ID de la transacción. La ejecución de este método marca en la base de datos *de T* a dicha transacción como (DELIVERED, NOTIFIED). *Luego de esa llamada al método de T*, *R* marca la transacción en estado (RESPONSIBLE, NOTIFIED). 

NOTE: El motivo por el cual primero se notifica y luego se confirma se hace para garantizar que la transacción fue correctamente confirmada por T antes de marcar que lo fue en la base de datos de R.

Aquí termina el protocolo de traspaso simple, pero podemos considerar un paso extra para contemplar la acción que realiza R sobre las transacciones recibidas. 

[start=6]
. R toma las transacciones en estado (RESPONSIBLE, NOTIFIED) y realiza su tarea. *Luego de aplcar la tarea* las pasa a (APPLIED, NOTIFIED)

.NOTAS DEL PROTOCOLO
* Dado que mencionamos dos métodos de T, podemos definir una interfaz llamada TransactionsSender que los identifique. 
** `List<TransactionInformation> getPendingTransactions()` para obtener la lista de transacciones a traspazar
** `void confirmReception(TransactionID x)` para comunicar la recepción de una transacción.

NOTE: La clase TransactionInformation 

* Cuando se involucra sólo a dos módulos (uno de tipo R y otro T), este protocolo se implementa con tres agentes en T y otros tres en R.
** El main thread de T es quien implementa la interfaz de transacciones de T (los métodos.
** En primer agente de T es quien monitorea la aparición de nuevas transacciones y las escribe en una tabla con el estado (RESPONSIBLE, NO_ACTION_INTENDED).
** El segundo agente mira esa tabla, ejecuta una lógica interna y cuando determina que deben traspasarse las transacciones a otro módulo pasa las transacciones correspondientes del estado (RESPONSIBLE, NO_ACTION_INTENDED) a (RESPONSIBLE, TO_BE_NOTIFIED)
** El tercer agente es quien se despierta periódicamente, y cuando encuentra transacciones en estado (RESPONSIBLE, TO_BE_NOTIFIED) o (RESPONSIBLE, NOTIFIED) envía el evento TransactionsWaitingTransferenceEvent y marca las que eran TO_BE_NOTIFIED como (RESPONSIBLE, NOTIFIED). *Notar que sigue en estado RESPONSIBLE*.
** El main thread de R es quien recibe los eventos de T y los registra en una base de datos interna.
** El primer agente lee los eventos de esta base de datos que llena el main thread, va a buscar la lista de transacciones a T y las guarda una por una en otra tabla de la base de datos con el estado (ACKNOWLEDGED, TO_BE_NOTIFIED).
** El segundo agente mira la tabla que llena el agente anterior con transacciones nuevas y le informa a T que recibió correctamente las transacciones de a una a la vez (a través del método `confirmReception`). Entonces, *tras confirmarle a T la recepción* pasa la misma al estado (RESPONSIBLE, NOTIFIED).
** El tercer agente aplica la tarea de R sobre las transacciones (RESPONSIBLE, NOTIFIED) y las pasa al estado (APPLIED, NO_ACTION_REQUIRED).

NOTE: La separación entre el agente 1 y el agente 2 de R es necesaria porque si se notoficara que llegó una transacción antes de marcarla como (ACKNOWLEDGED, TO_BE_NOTIFIED) y luego se apagara el sistema, la transacción no se habría registrado y el emisor la tendría marcada como notificada. 

IMPORTANT: TODO: ME PARECE QUE SE PEDEN INVERTIR PERSISTIENDO PRIMERO Y LLAMÁNDO AL MÉTODO DESPUÉS DADO QUE DE TODAS FORMAS ESTAMOS PREPARADOS PARA QUE NOS MANDEN LA MISMA TRASACCIÓN MÁS DE UNA VEZ.

* <<Fermat-DMP-CryptoTransactionLayer-TransactionTransferProtocol-SBDProtocol,Más adelante>> hablaremos del caso de una comunicación que involucra tres módulos, uno de tipo T (emisor original), uno de tipo R (receptor final) y un módulo intermedio que actúa como tipo R para el emisor original y como tipo T para el receptor final (un puente).
* Al iniciarse un módulo de tipo R, deberá consultar si sus módulos T asociados tienen transacciones acumuladas. Esto se debe a que el módulo pudo inicializarse tras haber perdido varias notificaciones de transacciones nuevas.
* Claramente puede llegar una nueva transacción a T antes que R procese toda la lista de transacciones que ha recibido en una consulta anterior. En este caso T podría disparar nuevamente el evento de que avisa que tiene nuevas transacciones. +
El primer thread de R recibirá ese evento, y luego el segundo thread probablemente traerá, en la lista de transacciones nueva, transacciones que ya ha registrado pero aún el tercer thread no ha confirmado recepción. +
Esto da lugar a que se intente guardar en la base de datos una transacción ya almacenada, dicho caso no deberá considerarse como un error y simplemente deberá ser ignorado. +
* Por otro lado T debe estar preparado para el aviso de que se desea notificar que una transacción se procesó más de una vez. Esto puede darse en el caso en que el tercer thread de R notificó la recepción pero no llegó a persistir en su base de datos el cambio de estado a NOTIFIED, T ignorará el aviso y si todo es correcto esta vez R sí podrá marcar la transacción como NOTIFIED.

== NOTAS PARA EZEQUIEL (DE LUIS)

Hasta acá todo bien en general. Lo unico que yo ajustaría sería la nomenclatura para que se alinie aun mas con la forma en que lo explicamos oralmente. Y ahí vuelvo al concepto de la responsabilidad de cada módulo. 

En las crypto networks o billeteras externas, las transacciones debieras tener estos estados:

Crypto Estado: SUBMITTED --> ACCEPTED --> CONFIRMED | REVERSED
Estado de la transacción: RESPONSABILITY --> DELIVERED
Estado de la notificación: NO_ACTION_REQUIRED --> TO_BE_NOTIFIED --> NOTIFIED

Por otro lado, los estados en R cuando es un puente, para mí serían: 

Estado de la transacción: ACKNOWLEDGED --> RESPONSABILITY --> DELIVERED
Estado de la notificación: NO_ACTION_REQUIRED --> TO_BE_NOTIFIED --> NOTIFIED

Finalmente en el R cuando es quien aplica las transacciones:

Estado de la transacción: ACKNOWLEDGED --> RESPONSABILITY --> APPLIED
Estado de la notificación: NO_ACTION_REQUIRED --> TO_BE_NOTIFIED --> NOTIFIED

La cadena en teoría tendría un nivel mas, donde el que sigue es la capa ahora llamada Device Private Network que se encargaría de sincronizar las transacciones en mas de un dispositivo. (Mas adelante)

Por otro lado, desde mi punto de vista, hablando del asunto de si R tiene que ir a buscar las transacciones cuando se levante por las dudas o T tiene que disparar un evento cada tanto si no le vienen a buscar una transacción yo creo que la solución es las dos cosas. 

Porque? 

1-Es responsabilidad de R tomar control de las transacciones, por lo tanto si el estuvo durmiendo, es lógico que cuando se despierta tiene que ir a ver si hay algo porque potencialmente se perdió los eventos.

2-Es responsabilidad de T entregar el control de la transaccion, con lo cual si nadie la viene a buscar, cada tanto tiene que seguir avisando. Esto en el futuro pudiera encender una acción en un ser superior que llamaremos Dios (D) que todo lo ve, y pudiera llegar a hacer algo con eso. JA JA JA.

Por favor usá lo que te escribí donde corresponda en tu texto.


[[Fermat-DMP-CryptoTransactionLayer-TransactionTransferProtocol-SBDProtocol]]
=== Caso de tres módulos

Llamaremos a este caso el Protocolo SBD (Protocolo **S**ource-**B**ridge-**D**estination). +
En este caso tenemos tres módulos involucrados en el intercambio de transacciones.

* Un módulo S de tipo T (emisor original).
* Un módulo D de tipo R (destinatario final)
* Un módulo B que es tanto de tipo T como R (puente entre E y R)

La utilidad de este protocolo se da cuando un módulo (S) debe delegar una transacción pero no tiene forma de saber a quién debe hacerlo. En este caso se coloca a un receptor temporal (B) que sí puede determinar quién es el receptor indicado para la transacción (D). +

La variación es leve, Los módulos S y D actuarán como explicamos antes en el protocolo simple (no saben que hay un puente), el puente "simplemente" hará que su cuarto thread lea la tabla que llena el thread 3 y actúa como un módulo tipo T cuya acción es envíar las transacciones cuando están en estado (RESPONSIBLE, NOTIFIED) en lugar de NEW). +
Al esperar que estén en NOTIFIED en lugar de NEW se garantiza que el traspazo de la transacción de S a B fue completado exitosamente antes de comenzar a transmitir de B a D.

Este protocolo será implementado por diversos plug-ins que interactúan con esta capa.

== Problemas a resolver

Con el planteo actual, al agregarse un plug-in que envíe eventos al incoming crypto (por ejemplo más redes crypto como la de litecoin), se deberán hacer modificaciones en incoming crypto para que pueda atender transacciones de ese nuevo plug-in. +
Para desacoplar esto requerimos dos cosas: +
Por un lado hay que buscar una alternativa para que los módulos tipo R no requieran consultar a sus T asociados al inicializarse (buscar que el incoming crypto no tenga que consultar al inicializarse a los módulos que le envían eventos). +
Algunas idras para solucionar eso serían:

* Que los módulos tipo T (los que envían eventos al incoming crypto) envíen periódicamente un evento que notifique que hay transacciones pendientes de transferir pocesión.

El otro problema consiste en que cuando el plug-in Incoming Crypto recibe un evento, debe tomar el origen del evento y usar la referencia del módulo correspondiente (ejemplo: bitcoin de la crypto network o blockchaininfo de world). Actualmente, por lo que entiendo esto se hace implementando una interfaz DealsWith por cada plug-in sobre el que se tiene que hacer referencia (ver nota de más abajo), pero esto no es apropiado para este caso porque implica que al agregar por ejemplo un módulo para la red litecoin en crypto network tendría que modificar esta capa para agregar las referencias. Por otro lado (e independientemente de si use uno o varios DealsWith) la referencia debe existir porque inevitablemente se debe interactuar con los plug-ins que reciben las transacciones.

NOTE: Quizás se pueda usar un solo DealsWith sobre una interfaz que en este caso es común a todos los módulos, sería la interfaz con los dos métodos de T que se describen, pero hay que analizar si la información de las transacciones es uniforme con todas las redes crypto. De todas formas, esto no resolvería el problema porque seguiría requiriendo referencias a los nuevos módulos que implementen esta interfaz.

Este problema lo veo repetido en varios lados, por ejemplo:

* En la capa de transacciones, dado el tipo de billetera debemos obtener el manejador adecuado para esa billetera
* También en la capa de transacciones, dado el tipo de red crypto necesitamos obtener una referencia en particular (en este caso el problema es más amplio porque puedo requerir las cosas de World, pero podría enviar en los eventos la capa de la que proviene el source además del identificador del mismo)
* En las nich wallet type, dado un tipo de transacción debemos obtener el manejador adecuado según el destino de la transacción (outgoing intra user, outgoing extra user)
* Creo que he visto este problema también cuando dado el tipo de usuario debemos obtener el manejador adecuado para ese usuario

Es posible (esto es sólo una idea) de que los componentes que realizan esa tarea (darte la referencia a la interfaz que uno busca en función al identificador del plug-in) deba incorporarse como una función de capa (o de un plug-in especial dentro de la capa). Así podríamos desacoplar mejor las cosas (al menos en esta capa). Si recibo un evento, busco la capa de la fuente (esta información debería venir en el evento) y le pido que me pase el manejador del plug-in que busco de esa capa (o plug-in especial dentro de esa capa), así si incorporan una nueva red crypto por ejemplo no tendré que cambiar nada en la capa de transacciones porque obtengo las referencias dinámicamente a medida que las necesito en lugar de obtenerlas todas juntas al momento de inicialización de la plataforma. 

== Plug-ins in this layer

:leveloffset: 2
include::incomingCrypto/developersIndex.asciidoc[]

:leveloffset: 2
include::outgoingCrypto/developersIndex.asciidoc[]

