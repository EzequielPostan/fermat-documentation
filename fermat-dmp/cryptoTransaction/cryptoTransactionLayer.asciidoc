[[Fermat-DMP-CryptoTransactionLayer]]
= Crypto Transaction Layer

[[Fermat-DMP-CryptoTransactionLayer-LayerDescription]]
== Layer Description

Transactions are one of the core functionalities developed over Fermat. +
Fermat uses crypto currencies to transfer the real value from a user to another, but we have to remember that you can make transactions of other assets apart from crypto currencies. +
For example, we can transfer 100 dollars from one wallet to another. The mechanism to do this involve the value transaction which is managed by transferring an amount of crypto currency like bitcoin equivalent to 100 dollars between the users and an information transaction which provide the information about the meaning of those bitcoins. In this case the information would be that the bitcoins sent by the crypto network are represented as 100 dollars. +

Therefore, when we make a transaction in Fermat we can identify two components: *meta data* and *value*. +
The value at this moment is stored at a crypto vault, specifically under a crypto addresses managed managed by the vault plugin. On the other hand the information tell us, among other things, which and how much fiat currency or other asset is beign transmitted. +

The meta data and the value travel through different channels, so they will be be acknowledged by a device at different moments in time. This means that we can receive a notification that 100 dollars have been sent to us before we get any new bitcoins that represent the value or vice versa, we can get new bitcoins before receiving the notification of what those bitcoins represent and why they have been sent. +

The responsibility of this layer is to keep these concepts synchronized and within each device the transactional and balance information in a consistent state. The plug-ins that live here detect the arrival of value and information and will update the balances of the system vaults and wallets in an atomic transactional way, i.e. they will update things only when both meta data *and* value are acknowledged. +
No loss of value nor meta data can be permitted. The mechanisms implemented by this layer will need to contemplate many different kinds of problems (device shut down, network failure, etc.).

NOTE: The plug-ins in this layer will need to communicate with the wallets and crypto vaults using events or at least a more complex mechanism that simple method call. The plug-ins need to know that the information inside the wallets and volt was actually updated and persisted before ending the synchronization protocol.

In the next section we will explore a general idea behind the protocols and failures considered in the design of this layer.

== Transaction Data Structure

To attack the problems we deal with in this layer we will need to design a few data structures to contain and share important information. +
To simplify the analysis let's give a name to the data strcutures that contains the value and information associated to the fermat transaction. We will call them ValueContainer and MetaValueContainer respectively. +

As we will get the value and meta-value separetely and in no predictable order we will to introduce in the MetaValueContainer a reference to the associated ValueContainer. In this way we will be able to know when we have all the information needed to reflect the transaction in the wallets among other components. +

The ValueContainer will store.

.ValueContainer Information
. The crypto currency we are dealing with as value.
. The amount of crypto currency. 
. A transaction identifier that distinguish the crypto transaction.
. The source crypto address of the transaction.
. The destination crypto address of the transaction.
. The timestamp that stablish the creation time of the transaction.

Note: In a single crypto transaction could be bundled many meta transactions.

.MetaValueContainer Information
. The asset represented by the transaction (fiat currency, bonds, etc)
. A representation of relevant information associated to the asset, e.g. in fiat currency would be the amount of currency involved.
. The transaction identifier of the associated ValueContainer.
. The timestamp that stablish the creation time of the transaction. For a simple secutiry mechanism we will ask for this timestamp to be the same timestamp present in the associated ValueContainer.

This cointainers descriptions are a draft presentation. We will add some fields to them to attack the syncronization problems. +

An important aspect to consider is that lower layers (like network services and crypto networks) will interact with this containers as they are the layers that will give us this information. +

== Transaction Protocol (DRAFT)

Este protocolo involucra dos tipos de módulos T y R. Los tipo T transfiere la responsabilidad de transacciones que poseen y los tipo R reciben la responsabilidad de las transacciones. +

IMPORTANT: Este protocolo asume que los módulos tipo R saben quienes son sus posible T asociados (quienes les transmiten transacciones).

Pensemos en la interacción de un módulo T que desea enviar una transacción a R. 

NOTE: Cuando digamos que T recibe una transacción, nos referimos a que tiene una nueva transacción que notificar.

.Pasos del protocolo
. T registra una transacción nueva que debe ceder a otro módulo, entonces la guarda en su base de datos interna con el estado NEW y notifica con un evento para que el módulo responsable busque dicha transacción.
. R escucha el evento de T, mira que el origen del evento es T y llama a un método de la interfaz de T que retorna una lista con todas las transacciones que tiene guardada en estado NEW. **T no cambia el estado de las transacciones que tiene almacenadas cuando R hace esta consulta.**
. R toma la lista y almacena en una base de datos interna cada transacción de a una a la vez con el estado NEW. 
. Luego, para cada transacción en estado NEW, R llama a otro método de T al cual le pasa el ID de la transacción y este marca en su base de datos interna a dicha transacción como OLD. *Luego de esa llamada para confirmar recepción* R marca la transacción en estado NOTIFIED. El motivo por el cual primero se notifica y luego se confirma se hace para garantizar que la transacción fue correctamente confirmada por T antes de marcar que lo fue en la base de datos.

.NOTAS DEL PROTOCOLO
* Cuando se involucra sólo a dos módulos (uno de tipo R y otro T), este protocolo se implementa con 3 threads en R.
** El primer thread es quien recibe los eventos de T y los registra en una base de datos interna.
** El segundo lee los eventos de esta base de datos que llena el thread anterior, va a buscar la lista de transacciones y las guarda una por una en otra base de datos.
** El tercero mira la base de datos del thread anterior con transacciones nuevas y le informa a T que recibió correctamente la transacción. Entonces pasa la misma al estado NOTIFIED.
* Más adelante hablaremos del caso de una comunicación que involucra tres módulos, uno de tipo T (emisor original), uno de tipo R (receptor final) y un puente de tipo que actúa como tipo R para el emisor y R para el receptor final (un puente).
* Al iniciarse un módulo de tipo R, deberá consultar si sus módulos T asociados tienen transacciones acumuladas. Esto se debe a que el módulo pudo inicializarse tras haber perdido varias notificaciones de transacciones nuevas.
* Claramente puede llegar una nueva transacción a T antes que R procese toda la lista de transacciones que ha recibido en una consulta anterior. En este caso T dispara nuevamente el evento de que tiene nuevas transacciones. +
El primer thread de R recibirá ese evento, y luego el segundo thread probablemente traerá en la lista de transacciones nueva transacciones que ya ha registrado pero aún el tercer thread no ha confirmado recepción. +
Esto da lugar a que se intente guardar en la base de datos una transacción ya guardada, dicho caso no deberá considerarse como un error y simplemente deberá ser ignorado. +
* Por otro lado T debe estar preparado para el aviso de que se desea notificar que una transacción se procesó más de una vez. Esto puede darse en el caso en que el tercer thread de R notificó la recepción pero no llegó a persistir en su base de datos el aviso de NOTIFIED, T ignorará el aviso y si todo es correcto esta vez R sí podrá marcar la transacción como NOTIFIED.

=== Caso de tres módulos

Llamaremos a este caso el Protocolo EPR (Protocolo **E**misor-**P**uente-**D**estinatario). +
En este caso tenemos tres módulos involucrados en el intercambio de transacciones.

* Un módulo E de tipo T (emisor original).
* Un módulo D de tipo R (destinatario final)
* Un módulo P que es tanto de tipo T como R (puente entre E y R)

La utilidad de este protocolo se da cuando un módulo (E) debe delegar una transacción pero no tiene forma de saber a quién debe hacerlo. En este caso se coloca a un receptor temporal (P) que sí puede determinar quién es el receptor indicado para la transacción (D). +

La variación es leve, Los módulos E y D actuarán como explicamos antes en el protocolo (no saben que hay un puente)

== Plug-ins in this layer

:leveloffset: 2
include::incomingCrypto/developersIndex.asciidoc[]

:leveloffset: 2
include::outgoingCrypto/developersIndex.asciidoc[]

